<html>
  <head>
  <script type="text/javascript" src="javascript/d3.v3.min.js"></script>
  <script type="text/javascript" src="javascript/jquery-2.0.2.min.js"></script>
  <script type="text/javascript" src="javascript/demo_data.js"></script>

  <style>
    body {
      margin: 0px;
      padding: 0px;
      font: 12px Arial;
    }
    .centered
		{
				width: 1280px;
				margin: auto;
				padding: auto;
				height: 800px;
				background: lightblue;
		}
		.svgButton
		{
			cursor: pointer
		}
		.unselected_outline
		{
			fill: rgba(0,0,0,0);
			stroke-width: 1;
			stroke: rgba(1,1,1,.2);
			stroke-opacity: 1;
		}
		.heavy_outline
		{
			fill: rgba(0,0,0,0);
			stroke-width: 1;
			stroke: rgba(1,1,1,1);
			stroke-opacity: 1;
		}
		.cell
		{
			fill: rgba(255,249,203,1);
			stroke: rgba(0,0,0,1);
		}
		.celltext
		{
			font: Calibri;
			font-size: 8;
		}

  </style>
	<title>Minardo</title>
  </head>
  <body>
  <div class="centered" id="box">
  </div>
<script>
// hard coded height/width due to projector screen

var height = 800,
		width = 1280,
		rowHeight = 12,
		rowWidth = width / headers.length;

var interval = 1500;

var header, rows;
// take only the first X entries, no need for a 37,000 array
var data = [];
for (var i = 0; i < height/rowHeight; i++){
	data.push(demo_data[i]);
}
var index = {};
demo_data.forEach(function (row){
	index[row.id] = row;
});

var vis = d3.select("#box").append("svg").attr("id", "vis");


//draw the spreadsheet
var ss = vis.append("svg:g").attr("id", "ss");
buildSpreadSheet(headers, data);

function cellText(x, y, group, text){
	var text = group.append("svg:text")
		.classed("celltext", true)
		.attr("x", x + 2)
		.attr("y", y + 9)
		.text(text);
	return text;
}

function makeCell(x, y, group, colour){
	var cell = group.append("svg:rect")
		.attr("height", rowHeight)
		.attr("width", rowWidth)
		.classed("cell", true)
		.attr("x", x)
		.attr("y", y);
	if (colour){
		cell.attr("style", "fill: "+colour+";");
	}
	return cell;
}

function buildHeaders(headers){
	d3.selectAll(".header").remove();
	d3.select("#header").remove();
	header = ss.append("svg:g").attr("id", "header");
	headers.forEach(function(title, i){
		var col = header.append("svg:g").attr("id", title)
			.classed("header", true)
			.classed(title, true);
		makeCell( i * rowWidth, 0, col);
		cellText( i * rowWidth, 0, col, title);
	});
}

function buildSpreadSheet(headers, data){
	buildHeaders(headers);
	d3.select("#top").remove();
	d3.select("#rows").remove();
	rows = ss.append("svg:g").attr("id", "rows");
	data.forEach(function(rowdata,i){
		var row = rows.append("svg:g").attr("id","row-"+rowdata.id).classed("row", true);
		Object.keys(rowdata).forEach(function (col, j){
			var cell = row.append("svg:g")
				.classed(col, true);
			makeCell( j * rowWidth , (i + 1) * rowHeight, cell);
			cellText( j * rowWidth , (i + 1) * rowHeight, cell, rowdata[col]);
		});
	});
}

function highlightNulls(){
	buildHeaders(headers);

	d3.selectAll(".row").remove();
	var rows = ss.append("svg:g").attr("id", "rows");
	data.forEach(function(rowdata,i){
		if(valid(rowdata)){
			var row = rows.append("svg:g");
			Object.keys(rowdata).forEach(function (col, j){
				var cell = row.append("svg:g")
					.classed(col, true);
				makeCell( j * rowWidth , (i + 1) * rowHeight, cell);
				cellText( j * rowWidth , (i + 1) * rowHeight, cell, rowdata[col]);
			});
		} else {
			var row = rows.append("svg:g");
			Object.keys(rowdata).forEach(function (col, j){
				var cell = row.append("svg:g")
					.classed(col, true);
				if(rowdata[col] == "null") {
					makeCell( j * rowWidth , (i + 1) * rowHeight, cell, "rgba(255,170,170,1)");
				} else {
					makeCell( j * rowWidth , (i + 1) * rowHeight, cell, "rgba(255,220,220,1)");
				}
				cellText( j * rowWidth , (i + 1) * rowHeight, cell, rowdata[col]);
			});
		}
	});
}

function valid(data){
	if (data.TCX_0_15sec == "null" &&
	data.TCX_1_15sec == "null" &&
	data.TCX_2_15sec == "null"){
		return false;
	} else if (
	data.TCX_0_30sec == "null" &&
	data.TCX_1_30sec == "null" &&
	data.TCX_2_30sec == "null"){
		return false;
	} else if (
	data.TCX_0_1min == "null" &&
	data.TCX_1_1min == "null" &&
	data.TCX_2_1min == "null"){
		return false;
	} else if (
	data.TCX_0_2min == "null" &&
	data.TCX_1_2min == "null" &&
	data.TCX_2_2min == "null"){
		return false;
	} else if (
	data.TCX_0_5min == "null" &&
	data.TCX_1_5min == "null" &&
	data.TCX_2_5min == "null"){
		return false;
	} else if (
	data.TCX_0_10min == "null" &&
	data.TCX_1_10min == "null" &&
	data.TCX_2_10min == "null"){
		return false;
	} else if (
	data.TCX_0_20min == "null" &&
	data.TCX_1_20min == "null" &&
	data.TCX_2_20min == "null"){
		return false;
	} else if (
	data.TCX_0_60min == "null" &&
	data.TCX_1_60min == "null" &&
	data.TCX_2_60min == "null"){
		return false;
	} else {
		return true;
	}
}

function filterNulls(){
	data = [];
	for (i = 0; data.length < 100; i++){
		var row = demo_data[i];
		if(valid(row)){
			data.push(row);
		}
		if(data.length > 100){
			return;
		}
	}
	buildSpreadSheet(headers, data);
}

function highlightExperiments(){
	buildHeaders(headers);
	d3.select("#rows").remove();
//	d3.selectAll(".row").remove();
	var rows = ss.append("svg:g").attr("id", "rows");
	data.forEach(function(rowdata,i){
		var row = rows.append("svg:g");
		Object.keys(rowdata).forEach(function (col, j){
			var cell = row.append("svg:g")
				.classed(col, true);
			if (experimentCell(col) && rowdata[col] != "null"){
				makeCell( j * rowWidth , (i + 1) * rowHeight, cell, experimentCell(col));
			} else {
				makeCell( j * rowWidth , (i + 1) * rowHeight, cell, mutedExperimentCell(col));
			}
			cellText( j * rowWidth , (i + 1) * rowHeight, cell, rowdata[col]);
		});
	});
}

function experimentCell(name){
	if (name == "TCX_0_15sec" ||
	name == "TCX_0_30sec" ||
	name == "TCX_0_1min" ||
	name == "TCX_0_2min" ||
	name == "TCX_0_5min" ||
	name == "TCX_0_10min" ||
	name == "TCX_0_20min" ||
	name == "TCX_0_60min") {
	return "rgba(255,170,170,1)";
	} else if (name == "TCX_1_15sec" ||
	name == "TCX_1_30sec" ||
	name == "TCX_1_1min" ||
	name == "TCX_1_2min" ||
	name == "TCX_1_5min" ||
	name == "TCX_1_10min" ||
	name == "TCX_1_20min" ||
	name == "TCX_1_60min") {
	return "rgba(170,255,170,1)";
	} else if (name == "TCX_2_15sec" ||
	name == "TCX_2_30sec" ||
	name == "TCX_2_1min" ||
	name == "TCX_2_2min" ||
	name == "TCX_2_5min" ||
	name == "TCX_2_10min" ||
	name == "TCX_2_20min" ||
	name == "TCX_2_60min") {
	return "rgba(170,170,255,1)";
	} else { return false;}	
}
function mutedExperimentCell(name){
	if (name == "TCX_0_15sec" ||
	name == "TCX_0_30sec" ||
	name == "TCX_0_1min" ||
	name == "TCX_0_2min" ||
	name == "TCX_0_5min" ||
	name == "TCX_0_10min" ||
	name == "TCX_0_20min" ||
	name == "TCX_0_60min") {
	return "rgba(255,220,220,1)";
	} else if (name == "TCX_1_15sec" ||
	name == "TCX_1_30sec" ||
	name == "TCX_1_1min" ||
	name == "TCX_1_2min" ||
	name == "TCX_1_5min" ||
	name == "TCX_1_10min" ||
	name == "TCX_1_20min" ||
	name == "TCX_1_60min") {
	return "rgba(220,255,220,1)";
	} else if (name == "TCX_2_15sec" ||
	name == "TCX_2_30sec" ||
	name == "TCX_2_1min" ||
	name == "TCX_2_2min" ||
	name == "TCX_2_5min" ||
	name == "TCX_2_10min" ||
	name == "TCX_2_20min" ||
	name == "TCX_2_60min") {
	return "rgba(220,220,255,1)";
	} else { return false;}	
}


function zoom(){
	$("#top").remove();
	var top = d3.select("#ss").append("svg:g").attr("id", "top");
	var c0 = top.append("svg:g").attr("id", "c0");
	var c1 = top.append("svg:g").attr("id", "c1");
	var c2 = top.append("svg:g").attr("id", "c2");
	$('#c0').append($('.TCX_0_15sec').detach());
	$('#c1').append($('.TCX_1_15sec').detach());
	$('#c2').append($('.TCX_2_15sec').detach());
	
	
//	data.forEach
	c0.transition(interval)
		.attr("transform", "matrix(8 0 0 8 -"+(rowWidth*4.5*8-rowWidth)+" 0)");
	c1.transition(interval)
		.attr("transform", "matrix(8 0 0 8 -"+(rowWidth*11.5*8-rowWidth)+" 0)");
	c2.transition(interval)
		.attr("transform", "matrix(8 0 0 8 -"+(rowWidth*18.5*8-rowWidth)+" 0)");
}

function getData(id){
	return index[id];
}




// cute snippet to push things to the front. Not standard d3.js
d3.selection.prototype.moveToFront = function() {
  return this.each(function(){
    this.parentNode.appendChild(this);
  });
};

</script>
  </body>
</html>


















































